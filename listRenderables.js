const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const templatesDir = path.join(__dirname, 'src', 'main', 'static', 'templates');
const outputFile = path.join(__dirname, 'src', 'renderer', 'codegen', 'sequential', 'ListRenderables.ts');

// Function to recursively find all .vemtl files
function findVemtlFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);
  
  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      findVemtlFiles(filePath, fileList);
    } else if (file.endsWith('.vemtl')) {
      fileList.push(filePath);
    }
  }
  
  return fileList;
}

// Function to extract renderable class name from template content
function extractRenderableClass(content) {
  const regex = /<#\s*DATA:RENDERABLE\s*\[\s*renderable\s*=\s*([^(]+)\(/;
  const match = content.match(regex);
  
  if (match && match[1] && match[1].trim() !== 'CustomRenderable') {
    return match[1].trim();
  }
  
  return null;
}

// Generate the TypeScript file with all renderables
function generateRenderablesFile(renderableClasses) {
  const uniqueRenderables = [...new Set(renderableClasses)].filter(Boolean).sort();
  
  const imports = uniqueRenderables.map(renderableClass => 
    `import ${renderableClass} from './${renderableClass}';`
  ).join('\n');
  
  const renderableMap = `
  const renderables = {
    ${uniqueRenderables.map(rc => `'${rc}': ${rc}`).join(',\n    ')}
  };
  `;
  
  const content = `// Auto-generated file - DO NOT EDIT MANUALLY
// Generated by listRenderables.js

${imports}

export default class ListRenderables {
  static getRenderable(name: string) {
    ${renderableMap}
    
    return renderables[name] || null;
  }
  
  static getRenderableNames(): string[] {
    return [
      ${uniqueRenderables.map(name => `'${name}'`).join(',\n      ')}
    ];
  }
}
`;
  
  fs.writeFileSync(outputFile, content);
  console.log(`Generated ${outputFile} with ${uniqueRenderables.length} renderables`);
  return uniqueRenderables;
}

// Main process
const vemtlFiles = findVemtlFiles(templatesDir);
console.log(`Found ${vemtlFiles.length} .vemtl files`);

const renderableClasses = [];
for (const file of vemtlFiles) {
  try {
    const content = fs.readFileSync(file, 'utf8');
    const renderableClass = extractRenderableClass(content);
    if (renderableClass) {
      renderableClasses.push(renderableClass);
    }
  } catch (error) {
    console.error(`Error processing ${file}:`, error.message);
  }
}

const uniqueRenderables = generateRenderablesFile(renderableClasses);
console.log('Found renderables:', uniqueRenderables);

// Add this script to package.json scripts if needed
try {
  const packageJsonPath = path.join(__dirname, 'package.json');
  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
  
  if (!packageJson.scripts || !packageJson.scripts.listRenderables) {
    packageJson.scripts = {
      ...packageJson.scripts,
      listRenderables: 'node listRenderables.js'
    };
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    console.log('Added listRenderables script to package.json');
  }
} catch (error) {
  console.warn('Could not update package.json:', error.message);
}

console.log('Done!');
