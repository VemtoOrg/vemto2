<?php

<% let extendsFrom = 'Model' %>
<% const camelCase = this.require('camelCase') %>

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
<% if(this.model.hasSoftDeletes) { %>
use Illuminate\Database\Eloquent\SoftDeletes;
<% } %>
<% if(this.model.isAuthenticatable) { %>
<% extendsFrom = 'Authenticatable' %>
use Illuminate\Foundation\Auth\User as Authenticatable;
<% } %>
// hook:IMPORTS

class <$ this.model.name $> extends <$ extendsFrom $> 
{
    use HasFactory;
    <% if(this.model.hasSoftDeletes) { %>
    use SoftDeletes;
    <% } %>
    // hook:TRAITS

    // hook:BEFORE_VARIABLES
    <% if(this.model.tableNameIsDifferentFromDefault()) { %>
    protected $table = '<$ this.model.table.name $>';
    <% } %>

    <% if(!this.model.hasTimestamps) { %>
    public $timestamps = false;
    <% } %>

    <% if(this.model.hasGuarded) { %>
    protected $guarded = [
        <% for(let column of this.model.guardedColumns) { %>
        '<$ column.name $>',
        <% } %>
    ];
    <% } %>

    <% if(this.model.hasFillable) { %>
    protected $fillable = [
        <% for(let column of this.model.fillableColumns) { %>
        '<$ column.name $>',
        <% } %>
    ];
    <% } %>

    <% if(this.model.hidden && this.model.hidden.length) { %>
    protected $hidden = [
        <% for(let column of this.model.hidden) { %>
        '<$ column $>',
        <% } %>
    ];
    <% } %>

    <% if(this.model.appends && this.model.appends.length) { %>
    protected $appends = [
        <% for(let column of this.model.appends) { %>
        '<$ column $>',
        <% } %>
    ];
    <% } %>

    <% if(this.model.dates && this.model.dates.length) { %>
    protected $dates = [
        <% for(let column of this.model.dates) { %>
        '<$ column $>',
        <% } %>
    ];
    <% } %>

    <% const castsColumns = Object.keys(this.model.casts || {}) %>
    <% if(castsColumns.length) { %>
    protected $casts = [
        <% for(let column of castsColumns) { %>
        '<$ column $>' => '<$ this.model.casts[column] $>',
        <% } %>
    ];
    <% } %>
    // hook:AFTER_VARIABLES

    // hook:BEFORE_METHODS
    <% if(this.model.ownRelationships.length) { %>
        <# Relationships #>
        <% for (let relationship of this.model.ownRelationships) { %>
            <# Belongs To #>
            <% if(relationship.type == "BelongsTo") { %>
            public function <$ relationship.name $>() 
            {
                return $this->belongsTo(<$ relationship.relatedModel.name $>::class
                <# Check if foreign key or parent key are different #>
                <up if(relationship.getServiceFromType().hasDifferentForeignOrParentKey()) { up>
                , '<$ relationship.foreignKeyName $>'
                <up } up>
                <# --- #>
                <up if(relationship.getServiceFromType().hasDifferentParentKey()) { up>
                , '<$ relationship.parentKey.name $>'
                <up } up>);
            }

            <% } %>
            <# Has Many #>
            <% if(relationship.type == "HasMany") { %>
            public function <$ relationship.name $>() 
            {
                return $this->hasMany(<$ relationship.relatedModel.name $>::class
                <# Check if foreign key or parent key are different #>
                <up if(relationship.getServiceFromType().hasDifferentForeignOrParentKey()) { up>
                , '<$ relationship.foreignKeyName $>'
                <up } up>
                <# --- #>
                <up if(relationship.getServiceFromType().hasDifferentParentKey()) { up>
                , '<$ relationship.parentKey.name $>'
                <up } up>);
            }

            <% } %>
            <# Has One #>
            <% if(relationship.type == "HasOne") { %>
            public function <$ relationship.name $>() 
            {
                return $this->hasOne(<$ relationship.relatedModel.name $>::class
                <# Check if foreign key or parent key are different #>
                <up if(relationship.getServiceFromType().hasDifferentForeignOrParentKey()) { up>
                , '<$ relationship.foreignKeyName $>'
                <up } up>
                <# --- #>
                <up if(relationship.getServiceFromType().hasDifferentParentKey()) { up>
                , '<$ relationship.parentKey.name $>'
                <up } up>);
            }

            <% } %>
            <# Many To Many #>
            <% if(relationship.isManyToMany()) { %>
                public function <$ relationship.name $>() 
                {
                    return $this->belongsToMany(<$ relationship.relatedModel.name $>::class
                    <# Needs to add the pivot table if localKey or foreignKey are not default #>
                    <up if(relationship.getServiceFromType().needsToAddPivotToModelTemplate()) { up>
                    , '<$ relationship.pivot.name $>'
                    <up } up>
                    <# --- #>
                    <up if(relationship.getServiceFromType().hasDifferentForeignOrRelatedPivotKeys()) { up>
                    , '<$ relationship.foreignPivotKey.name $>'
                    <up } up>
                    <# --- #>
                    <up if(relationship.getServiceFromType().hasDifferentRelatedPivot()) { up>
                    , '<$ relationship.relatedPivotKey.name $>'
                    <up } up>);
                }

            <% } %>
            <# Morphs #>
            <% if(relationship.isMorph()) { %>
                public function <$ relationship.name $>() 
                {
                    return $this-><$ relationship.getTypeCamelCase() $>(<$ relationship.relatedModel.name $>::class, '<$ relationship.morphToName $>');
                }

            <% } %>
            <# Has Many Through #>
            <% if(relationship.isThrough()) { %>
                public function <$ relationship.name $>() 
                {
                    return $this-><$ relationship.getTypeCamelCase() $>(<$ relationship.relatedModel.name $>::class, <$ relationship.through.name $>::class
                    <up if(relationship.getServiceFromType().needsToAddFirstKeyNameToModelTemplate()) { up>
                    , '<$ relationship.firstKeyName $>'
                    <up } up>
                    <up if(relationship.getServiceFromType().hasDifferentSecondKeyName()) { up>
                    , '<$ relationship.secondKeyName $>'
                    <up } up>);
                }

            <% } %>
        <% } %>
    <% } %>
    
    <% if(this.model.relatedRelationships.length) { %>
        <# Basic Morph Inverse Relationships #>
        <% for(let relationship of this.model.getCommonMorphInverseRelationships()) { %>
            public function <$ relationship.morphToName $>() 
            {
                return $this->morphTo();
            }

        <% } %>

        <# MorphedByMany Relationships #>
        <% for(let relationship of this.model.getMorphedToManyRelatedRelationships()) { %>
            public function <$ camelCase(relationship.model.plural) $>() 
            {
                return $this->morphedByMany(<$ relationship.model.name $>::class, '<$ relationship.morphToName $>');
            }

        <% } %>
    <% } %>

    <# The following code is used by PHP-Merger to remove methods #>
    <% for(let relationship of this.model.getRemovedRelationships()) { %>
    // remove_method:<% relationship.name %>
    <% } %>
    <% for(let relationship of this.model.getRenamedRelationships()) { %>
    // remove_method:<% relationship.getOldName() %>
    <% } %>

    // hook:AFTER_METHODS
}